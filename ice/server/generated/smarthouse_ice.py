# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.3
#
# <auto-generated>
#
# Generated from file `smarthouse.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module SmartHouse
_M_SmartHouse = Ice.openModule('SmartHouse')
__name__ = 'SmartHouse'

if 'PowerState' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.PowerState = Ice.createTempClass()
    class PowerState(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    PowerState.ON = PowerState("ON", 0)
    PowerState.OFF = PowerState("OFF", 1)
    PowerState._enumerators = { 0:PowerState.ON, 1:PowerState.OFF }

    _M_SmartHouse._t_PowerState = IcePy.defineEnum('::SmartHouse::PowerState', PowerState, (), PowerState._enumerators)

    _M_SmartHouse.PowerState = PowerState
    del PowerState

if 'CoffeeType' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.CoffeeType = Ice.createTempClass()
    class CoffeeType(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    CoffeeType.BLACK = CoffeeType("BLACK", 0)
    CoffeeType.WHITE = CoffeeType("WHITE", 1)
    CoffeeType.LATTE = CoffeeType("LATTE", 2)
    CoffeeType.ESPRESSO = CoffeeType("ESPRESSO", 3)
    CoffeeType._enumerators = { 0:CoffeeType.BLACK, 1:CoffeeType.WHITE, 2:CoffeeType.LATTE, 3:CoffeeType.ESPRESSO }

    _M_SmartHouse._t_CoffeeType = IcePy.defineEnum('::SmartHouse::CoffeeType', CoffeeType, (), CoffeeType._enumerators)

    _M_SmartHouse.CoffeeType = CoffeeType
    del CoffeeType

if 'TeaType' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.TeaType = Ice.createTempClass()
    class TeaType(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    TeaType.BLACK = TeaType("BLACK", 0)
    TeaType.GREEN = TeaType("GREEN", 1)
    TeaType.WHITE = TeaType("WHITE", 2)
    TeaType._enumerators = { 0:TeaType.BLACK, 1:TeaType.GREEN, 2:TeaType.WHITE }

    _M_SmartHouse._t_TeaType = IcePy.defineEnum('::SmartHouse::TeaType', TeaType, (), TeaType._enumerators)

    _M_SmartHouse.TeaType = TeaType
    del TeaType

if 'Color' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.Color = Ice.createTempClass()
    class Color(Ice.EnumBase):

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    Color.RED = Color("RED", 0)
    Color.BLUE = Color("BLUE", 1)
    Color.GREEN = Color("GREEN", 2)
    Color.YELLOW = Color("YELLOW", 3)
    Color.WHITE = Color("WHITE", 4)
    Color._enumerators = { 0:Color.RED, 1:Color.BLUE, 2:Color.GREEN, 3:Color.YELLOW, 4:Color.WHITE }

    _M_SmartHouse._t_Color = IcePy.defineEnum('::SmartHouse::Color', Color, (), Color._enumerators)

    _M_SmartHouse.Color = Color
    del Color

if '_t_AvailableTeaTypes' not in _M_SmartHouse.__dict__:
    _M_SmartHouse._t_AvailableTeaTypes = IcePy.defineSequence('::SmartHouse::AvailableTeaTypes', (), _M_SmartHouse._t_TeaType)

if '_t_AvailableCoffeeTypes' not in _M_SmartHouse.__dict__:
    _M_SmartHouse._t_AvailableCoffeeTypes = IcePy.defineSequence('::SmartHouse::AvailableCoffeeTypes', (), _M_SmartHouse._t_CoffeeType)

if 'TimeOfDay' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.TimeOfDay = Ice.createTempClass()
    class TimeOfDay(object):
        def __init__(self, hour=0, minute=0, second=0):
            self.hour = hour
            self.minute = minute
            self.second = second

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.hour)
            _h = 5 * _h + Ice.getHash(self.minute)
            _h = 5 * _h + Ice.getHash(self.second)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_SmartHouse.TimeOfDay):
                return NotImplemented
            else:
                if self.hour is None or other.hour is None:
                    if self.hour != other.hour:
                        return (-1 if self.hour is None else 1)
                else:
                    if self.hour < other.hour:
                        return -1
                    elif self.hour > other.hour:
                        return 1
                if self.minute is None or other.minute is None:
                    if self.minute != other.minute:
                        return (-1 if self.minute is None else 1)
                else:
                    if self.minute < other.minute:
                        return -1
                    elif self.minute > other.minute:
                        return 1
                if self.second is None or other.second is None:
                    if self.second != other.second:
                        return (-1 if self.second is None else 1)
                else:
                    if self.second < other.second:
                        return -1
                    elif self.second > other.second:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_TimeOfDay)

        __repr__ = __str__

    _M_SmartHouse._t_TimeOfDay = IcePy.defineStruct('::SmartHouse::TimeOfDay', TimeOfDay, (), (
        ('hour', (), IcePy._t_short),
        ('minute', (), IcePy._t_short),
        ('second', (), IcePy._t_short)
    ))

    _M_SmartHouse.TimeOfDay = TimeOfDay
    del TimeOfDay

if 'Error' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.Error = Ice.createTempClass()
    class Error(Ice.UserException):
        def __init__(self, errorTime=Ice._struct_marker, reason=''):
            if errorTime is Ice._struct_marker:
                self.errorTime = _M_SmartHouse.TimeOfDay()
            else:
                self.errorTime = errorTime
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::Error'

    _M_SmartHouse._t_Error = IcePy.defineException('::SmartHouse::Error', Error, (), False, None, (
        ('errorTime', (), _M_SmartHouse._t_TimeOfDay, False, 0),
        ('reason', (), IcePy._t_string, False, 0)
    ))
    Error._ice_type = _M_SmartHouse._t_Error

    _M_SmartHouse.Error = Error
    del Error

if 'OutOfRangeError' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.OutOfRangeError = Ice.createTempClass()
    class OutOfRangeError(_M_SmartHouse.Error):
        def __init__(self, errorTime=Ice._struct_marker, reason=''):
            _M_SmartHouse.Error.__init__(self, errorTime, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::OutOfRangeError'

    _M_SmartHouse._t_OutOfRangeError = IcePy.defineException('::SmartHouse::OutOfRangeError', OutOfRangeError, (), False, _M_SmartHouse._t_Error, ())
    OutOfRangeError._ice_type = _M_SmartHouse._t_OutOfRangeError

    _M_SmartHouse.OutOfRangeError = OutOfRangeError
    del OutOfRangeError

if 'AlreadyOffError' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.AlreadyOffError = Ice.createTempClass()
    class AlreadyOffError(_M_SmartHouse.Error):
        def __init__(self, errorTime=Ice._struct_marker, reason=''):
            _M_SmartHouse.Error.__init__(self, errorTime, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::AlreadyOffError'

    _M_SmartHouse._t_AlreadyOffError = IcePy.defineException('::SmartHouse::AlreadyOffError', AlreadyOffError, (), False, _M_SmartHouse._t_Error, ())
    AlreadyOffError._ice_type = _M_SmartHouse._t_AlreadyOffError

    _M_SmartHouse.AlreadyOffError = AlreadyOffError
    del AlreadyOffError

if 'AlreadyOnError' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.AlreadyOnError = Ice.createTempClass()
    class AlreadyOnError(_M_SmartHouse.Error):
        def __init__(self, errorTime=Ice._struct_marker, reason=''):
            _M_SmartHouse.Error.__init__(self, errorTime, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::AlreadyOnError'

    _M_SmartHouse._t_AlreadyOnError = IcePy.defineException('::SmartHouse::AlreadyOnError', AlreadyOnError, (), False, _M_SmartHouse._t_Error, ())
    AlreadyOnError._ice_type = _M_SmartHouse._t_AlreadyOnError

    _M_SmartHouse.AlreadyOnError = AlreadyOnError
    del AlreadyOnError

if 'NoIngredientsError' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.NoIngredientsError = Ice.createTempClass()
    class NoIngredientsError(_M_SmartHouse.Error):
        def __init__(self, errorTime=Ice._struct_marker, reason=''):
            _M_SmartHouse.Error.__init__(self, errorTime, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::NoIngredientsError'

    _M_SmartHouse._t_NoIngredientsError = IcePy.defineException('::SmartHouse::NoIngredientsError', NoIngredientsError, (), False, _M_SmartHouse._t_Error, ())
    NoIngredientsError._ice_type = _M_SmartHouse._t_NoIngredientsError

    _M_SmartHouse.NoIngredientsError = NoIngredientsError
    del NoIngredientsError

if 'IsOffError' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.IsOffError = Ice.createTempClass()
    class IsOffError(_M_SmartHouse.Error):
        def __init__(self, errorTime=Ice._struct_marker, reason=''):
            _M_SmartHouse.Error.__init__(self, errorTime, reason)

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::SmartHouse::IsOffError'

    _M_SmartHouse._t_IsOffError = IcePy.defineException('::SmartHouse::IsOffError', IsOffError, (), False, _M_SmartHouse._t_Error, ())
    IsOffError._ice_type = _M_SmartHouse._t_IsOffError

    _M_SmartHouse.IsOffError = IsOffError
    del IsOffError

_M_SmartHouse._t_IDevice = IcePy.defineValue('::SmartHouse::IDevice', Ice.Value, -1, (), False, True, None, ())

if 'IDevicePrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.IDevicePrx = Ice.createTempClass()
    class IDevicePrx(Ice.ObjectPrx):

        def getPowerState(self, context=None):
            return _M_SmartHouse.IDevice._op_getPowerState.invoke(self, ((), context))

        def getPowerStateAsync(self, context=None):
            return _M_SmartHouse.IDevice._op_getPowerState.invokeAsync(self, ((), context))

        def begin_getPowerState(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.IDevice._op_getPowerState.begin(self, ((), _response, _ex, _sent, context))

        def end_getPowerState(self, _r):
            return _M_SmartHouse.IDevice._op_getPowerState.end(self, _r)

        def turnOn(self, context=None):
            return _M_SmartHouse.IDevice._op_turnOn.invoke(self, ((), context))

        def turnOnAsync(self, context=None):
            return _M_SmartHouse.IDevice._op_turnOn.invokeAsync(self, ((), context))

        def begin_turnOn(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.IDevice._op_turnOn.begin(self, ((), _response, _ex, _sent, context))

        def end_turnOn(self, _r):
            return _M_SmartHouse.IDevice._op_turnOn.end(self, _r)

        def turnOff(self, context=None):
            return _M_SmartHouse.IDevice._op_turnOff.invoke(self, ((), context))

        def turnOffAsync(self, context=None):
            return _M_SmartHouse.IDevice._op_turnOff.invokeAsync(self, ((), context))

        def begin_turnOff(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.IDevice._op_turnOff.begin(self, ((), _response, _ex, _sent, context))

        def end_turnOff(self, _r):
            return _M_SmartHouse.IDevice._op_turnOff.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.IDevicePrx.ice_checkedCast(proxy, '::SmartHouse::IDevice', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.IDevicePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::IDevice'
    _M_SmartHouse._t_IDevicePrx = IcePy.defineProxy('::SmartHouse::IDevice', IDevicePrx)

    _M_SmartHouse.IDevicePrx = IDevicePrx
    del IDevicePrx

    _M_SmartHouse.IDevice = Ice.createTempClass()
    class IDevice(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::IDevice')

        def ice_id(self, current=None):
            return '::SmartHouse::IDevice'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::IDevice'

        def getPowerState(self, current=None):
            raise NotImplementedError("servant method 'getPowerState' not implemented")

        def turnOn(self, current=None):
            raise NotImplementedError("servant method 'turnOn' not implemented")

        def turnOff(self, current=None):
            raise NotImplementedError("servant method 'turnOff' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_IDeviceDisp)

        __repr__ = __str__

    _M_SmartHouse._t_IDeviceDisp = IcePy.defineClass('::SmartHouse::IDevice', IDevice, (), None, ())
    IDevice._ice_type = _M_SmartHouse._t_IDeviceDisp

    IDevice._op_getPowerState = IcePy.Operation('getPowerState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_SmartHouse._t_PowerState, False, 0), ())
    IDevice._op_turnOn = IcePy.Operation('turnOn', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHouse._t_AlreadyOnError,))
    IDevice._op_turnOff = IcePy.Operation('turnOff', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_SmartHouse._t_AlreadyOffError,))

    _M_SmartHouse.IDevice = IDevice
    del IDevice

_M_SmartHouse._t_Fridge = IcePy.defineValue('::SmartHouse::Fridge', Ice.Value, -1, (), False, True, None, ())

if 'FridgePrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.FridgePrx = Ice.createTempClass()
    class FridgePrx(_M_SmartHouse.IDevicePrx):

        def getTemperature(self, context=None):
            return _M_SmartHouse.Fridge._op_getTemperature.invoke(self, ((), context))

        def getTemperatureAsync(self, context=None):
            return _M_SmartHouse.Fridge._op_getTemperature.invokeAsync(self, ((), context))

        def begin_getTemperature(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Fridge._op_getTemperature.begin(self, ((), _response, _ex, _sent, context))

        def end_getTemperature(self, _r):
            return _M_SmartHouse.Fridge._op_getTemperature.end(self, _r)

        def setTemperature(self, temperature, context=None):
            return _M_SmartHouse.Fridge._op_setTemperature.invoke(self, ((temperature, ), context))

        def setTemperatureAsync(self, temperature, context=None):
            return _M_SmartHouse.Fridge._op_setTemperature.invokeAsync(self, ((temperature, ), context))

        def begin_setTemperature(self, temperature, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Fridge._op_setTemperature.begin(self, ((temperature, ), _response, _ex, _sent, context))

        def end_setTemperature(self, _r):
            return _M_SmartHouse.Fridge._op_setTemperature.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.FridgePrx.ice_checkedCast(proxy, '::SmartHouse::Fridge', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.FridgePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::Fridge'
    _M_SmartHouse._t_FridgePrx = IcePy.defineProxy('::SmartHouse::Fridge', FridgePrx)

    _M_SmartHouse.FridgePrx = FridgePrx
    del FridgePrx

    _M_SmartHouse.Fridge = Ice.createTempClass()
    class Fridge(_M_SmartHouse.IDevice):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::Fridge', '::SmartHouse::IDevice')

        def ice_id(self, current=None):
            return '::SmartHouse::Fridge'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::Fridge'

        def getTemperature(self, current=None):
            raise NotImplementedError("servant method 'getTemperature' not implemented")

        def setTemperature(self, temperature, current=None):
            raise NotImplementedError("servant method 'setTemperature' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_FridgeDisp)

        __repr__ = __str__

    _M_SmartHouse._t_FridgeDisp = IcePy.defineClass('::SmartHouse::Fridge', Fridge, (), None, (_M_SmartHouse._t_IDeviceDisp,))
    Fridge._ice_type = _M_SmartHouse._t_FridgeDisp

    Fridge._op_getTemperature = IcePy.Operation('getTemperature', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_float, False, 0), (_M_SmartHouse._t_IsOffError,))
    Fridge._op_setTemperature = IcePy.Operation('setTemperature', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_float, False, 0),), (), None, (_M_SmartHouse._t_OutOfRangeError, _M_SmartHouse._t_IsOffError))

    _M_SmartHouse.Fridge = Fridge
    del Fridge

_M_SmartHouse._t_Lamp = IcePy.defineValue('::SmartHouse::Lamp', Ice.Value, -1, (), False, True, None, ())

if 'LampPrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.LampPrx = Ice.createTempClass()
    class LampPrx(_M_SmartHouse.IDevicePrx):

        def getColor(self, context=None):
            return _M_SmartHouse.Lamp._op_getColor.invoke(self, ((), context))

        def getColorAsync(self, context=None):
            return _M_SmartHouse.Lamp._op_getColor.invokeAsync(self, ((), context))

        def begin_getColor(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Lamp._op_getColor.begin(self, ((), _response, _ex, _sent, context))

        def end_getColor(self, _r):
            return _M_SmartHouse.Lamp._op_getColor.end(self, _r)

        def setColor(self, color, context=None):
            return _M_SmartHouse.Lamp._op_setColor.invoke(self, ((color, ), context))

        def setColorAsync(self, color, context=None):
            return _M_SmartHouse.Lamp._op_setColor.invokeAsync(self, ((color, ), context))

        def begin_setColor(self, color, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.Lamp._op_setColor.begin(self, ((color, ), _response, _ex, _sent, context))

        def end_setColor(self, _r):
            return _M_SmartHouse.Lamp._op_setColor.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.LampPrx.ice_checkedCast(proxy, '::SmartHouse::Lamp', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.LampPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::Lamp'
    _M_SmartHouse._t_LampPrx = IcePy.defineProxy('::SmartHouse::Lamp', LampPrx)

    _M_SmartHouse.LampPrx = LampPrx
    del LampPrx

    _M_SmartHouse.Lamp = Ice.createTempClass()
    class Lamp(_M_SmartHouse.IDevice):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::IDevice', '::SmartHouse::Lamp')

        def ice_id(self, current=None):
            return '::SmartHouse::Lamp'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::Lamp'

        def getColor(self, current=None):
            raise NotImplementedError("servant method 'getColor' not implemented")

        def setColor(self, color, current=None):
            raise NotImplementedError("servant method 'setColor' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_LampDisp)

        __repr__ = __str__

    _M_SmartHouse._t_LampDisp = IcePy.defineClass('::SmartHouse::Lamp', Lamp, (), None, (_M_SmartHouse._t_IDeviceDisp,))
    Lamp._ice_type = _M_SmartHouse._t_LampDisp

    Lamp._op_getColor = IcePy.Operation('getColor', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_SmartHouse._t_Color, False, 0), (_M_SmartHouse._t_IsOffError,))
    Lamp._op_setColor = IcePy.Operation('setColor', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHouse._t_Color, False, 0),), (), None, (_M_SmartHouse._t_IsOffError,))

    _M_SmartHouse.Lamp = Lamp
    del Lamp

_M_SmartHouse._t_IDrinkMachine = IcePy.defineValue('::SmartHouse::IDrinkMachine', Ice.Value, -1, (), False, True, None, ())

if 'IDrinkMachinePrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.IDrinkMachinePrx = Ice.createTempClass()
    class IDrinkMachinePrx(_M_SmartHouse.IDevicePrx):

        def addSugar(self, spoons, context=None):
            return _M_SmartHouse.IDrinkMachine._op_addSugar.invoke(self, ((spoons, ), context))

        def addSugarAsync(self, spoons, context=None):
            return _M_SmartHouse.IDrinkMachine._op_addSugar.invokeAsync(self, ((spoons, ), context))

        def begin_addSugar(self, spoons, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.IDrinkMachine._op_addSugar.begin(self, ((spoons, ), _response, _ex, _sent, context))

        def end_addSugar(self, _r):
            return _M_SmartHouse.IDrinkMachine._op_addSugar.end(self, _r)

        def addMilk(self, mililitres, context=None):
            return _M_SmartHouse.IDrinkMachine._op_addMilk.invoke(self, ((mililitres, ), context))

        def addMilkAsync(self, mililitres, context=None):
            return _M_SmartHouse.IDrinkMachine._op_addMilk.invokeAsync(self, ((mililitres, ), context))

        def begin_addMilk(self, mililitres, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.IDrinkMachine._op_addMilk.begin(self, ((mililitres, ), _response, _ex, _sent, context))

        def end_addMilk(self, _r):
            return _M_SmartHouse.IDrinkMachine._op_addMilk.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.IDrinkMachinePrx.ice_checkedCast(proxy, '::SmartHouse::IDrinkMachine', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.IDrinkMachinePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::IDrinkMachine'
    _M_SmartHouse._t_IDrinkMachinePrx = IcePy.defineProxy('::SmartHouse::IDrinkMachine', IDrinkMachinePrx)

    _M_SmartHouse.IDrinkMachinePrx = IDrinkMachinePrx
    del IDrinkMachinePrx

    _M_SmartHouse.IDrinkMachine = Ice.createTempClass()
    class IDrinkMachine(_M_SmartHouse.IDevice):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::IDevice', '::SmartHouse::IDrinkMachine')

        def ice_id(self, current=None):
            return '::SmartHouse::IDrinkMachine'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::IDrinkMachine'

        def addSugar(self, spoons, current=None):
            raise NotImplementedError("servant method 'addSugar' not implemented")

        def addMilk(self, mililitres, current=None):
            raise NotImplementedError("servant method 'addMilk' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_IDrinkMachineDisp)

        __repr__ = __str__

    _M_SmartHouse._t_IDrinkMachineDisp = IcePy.defineClass('::SmartHouse::IDrinkMachine', IDrinkMachine, (), None, (_M_SmartHouse._t_IDeviceDisp,))
    IDrinkMachine._ice_type = _M_SmartHouse._t_IDrinkMachineDisp

    IDrinkMachine._op_addSugar = IcePy.Operation('addSugar', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0),), (), None, (_M_SmartHouse._t_NoIngredientsError, _M_SmartHouse._t_OutOfRangeError, _M_SmartHouse._t_IsOffError))
    IDrinkMachine._op_addMilk = IcePy.Operation('addMilk', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0),), (), None, (_M_SmartHouse._t_NoIngredientsError, _M_SmartHouse._t_OutOfRangeError, _M_SmartHouse._t_IsOffError))

    _M_SmartHouse.IDrinkMachine = IDrinkMachine
    del IDrinkMachine

_M_SmartHouse._t_CoffeeMachine = IcePy.defineValue('::SmartHouse::CoffeeMachine', Ice.Value, -1, (), False, True, None, ())

if 'CoffeeMachinePrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.CoffeeMachinePrx = Ice.createTempClass()
    class CoffeeMachinePrx(_M_SmartHouse.IDrinkMachinePrx):

        def makeCoffee(self, coffeeType, context=None):
            return _M_SmartHouse.CoffeeMachine._op_makeCoffee.invoke(self, ((coffeeType, ), context))

        def makeCoffeeAsync(self, coffeeType, context=None):
            return _M_SmartHouse.CoffeeMachine._op_makeCoffee.invokeAsync(self, ((coffeeType, ), context))

        def begin_makeCoffee(self, coffeeType, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.CoffeeMachine._op_makeCoffee.begin(self, ((coffeeType, ), _response, _ex, _sent, context))

        def end_makeCoffee(self, _r):
            return _M_SmartHouse.CoffeeMachine._op_makeCoffee.end(self, _r)

        def getAvailableCoffeeTypes(self, context=None):
            return _M_SmartHouse.CoffeeMachine._op_getAvailableCoffeeTypes.invoke(self, ((), context))

        def getAvailableCoffeeTypesAsync(self, context=None):
            return _M_SmartHouse.CoffeeMachine._op_getAvailableCoffeeTypes.invokeAsync(self, ((), context))

        def begin_getAvailableCoffeeTypes(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.CoffeeMachine._op_getAvailableCoffeeTypes.begin(self, ((), _response, _ex, _sent, context))

        def end_getAvailableCoffeeTypes(self, _r):
            return _M_SmartHouse.CoffeeMachine._op_getAvailableCoffeeTypes.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.CoffeeMachinePrx.ice_checkedCast(proxy, '::SmartHouse::CoffeeMachine', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.CoffeeMachinePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::CoffeeMachine'
    _M_SmartHouse._t_CoffeeMachinePrx = IcePy.defineProxy('::SmartHouse::CoffeeMachine', CoffeeMachinePrx)

    _M_SmartHouse.CoffeeMachinePrx = CoffeeMachinePrx
    del CoffeeMachinePrx

    _M_SmartHouse.CoffeeMachine = Ice.createTempClass()
    class CoffeeMachine(_M_SmartHouse.IDrinkMachine):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::CoffeeMachine', '::SmartHouse::IDevice', '::SmartHouse::IDrinkMachine')

        def ice_id(self, current=None):
            return '::SmartHouse::CoffeeMachine'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::CoffeeMachine'

        def makeCoffee(self, coffeeType, current=None):
            raise NotImplementedError("servant method 'makeCoffee' not implemented")

        def getAvailableCoffeeTypes(self, current=None):
            raise NotImplementedError("servant method 'getAvailableCoffeeTypes' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_CoffeeMachineDisp)

        __repr__ = __str__

    _M_SmartHouse._t_CoffeeMachineDisp = IcePy.defineClass('::SmartHouse::CoffeeMachine', CoffeeMachine, (), None, (_M_SmartHouse._t_IDrinkMachineDisp,))
    CoffeeMachine._ice_type = _M_SmartHouse._t_CoffeeMachineDisp

    CoffeeMachine._op_makeCoffee = IcePy.Operation('makeCoffee', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHouse._t_CoffeeType, False, 0),), (), None, (_M_SmartHouse._t_NoIngredientsError, _M_SmartHouse._t_IsOffError))
    CoffeeMachine._op_getAvailableCoffeeTypes = IcePy.Operation('getAvailableCoffeeTypes', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_SmartHouse._t_AvailableCoffeeTypes, False, 0), (_M_SmartHouse._t_IsOffError,))

    _M_SmartHouse.CoffeeMachine = CoffeeMachine
    del CoffeeMachine

_M_SmartHouse._t_TeaMachine = IcePy.defineValue('::SmartHouse::TeaMachine', Ice.Value, -1, (), False, True, None, ())

if 'TeaMachinePrx' not in _M_SmartHouse.__dict__:
    _M_SmartHouse.TeaMachinePrx = Ice.createTempClass()
    class TeaMachinePrx(_M_SmartHouse.IDrinkMachinePrx):

        def makeTea(self, teaType, context=None):
            return _M_SmartHouse.TeaMachine._op_makeTea.invoke(self, ((teaType, ), context))

        def makeTeaAsync(self, teaType, context=None):
            return _M_SmartHouse.TeaMachine._op_makeTea.invokeAsync(self, ((teaType, ), context))

        def begin_makeTea(self, teaType, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.TeaMachine._op_makeTea.begin(self, ((teaType, ), _response, _ex, _sent, context))

        def end_makeTea(self, _r):
            return _M_SmartHouse.TeaMachine._op_makeTea.end(self, _r)

        def getAvailableTeaTypes(self, context=None):
            return _M_SmartHouse.TeaMachine._op_getAvailableTeaTypes.invoke(self, ((), context))

        def getAvailableTeaTypesAsync(self, context=None):
            return _M_SmartHouse.TeaMachine._op_getAvailableTeaTypes.invokeAsync(self, ((), context))

        def begin_getAvailableTeaTypes(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_SmartHouse.TeaMachine._op_getAvailableTeaTypes.begin(self, ((), _response, _ex, _sent, context))

        def end_getAvailableTeaTypes(self, _r):
            return _M_SmartHouse.TeaMachine._op_getAvailableTeaTypes.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_SmartHouse.TeaMachinePrx.ice_checkedCast(proxy, '::SmartHouse::TeaMachine', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_SmartHouse.TeaMachinePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::TeaMachine'
    _M_SmartHouse._t_TeaMachinePrx = IcePy.defineProxy('::SmartHouse::TeaMachine', TeaMachinePrx)

    _M_SmartHouse.TeaMachinePrx = TeaMachinePrx
    del TeaMachinePrx

    _M_SmartHouse.TeaMachine = Ice.createTempClass()
    class TeaMachine(_M_SmartHouse.IDrinkMachine):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::SmartHouse::IDevice', '::SmartHouse::IDrinkMachine', '::SmartHouse::TeaMachine')

        def ice_id(self, current=None):
            return '::SmartHouse::TeaMachine'

        @staticmethod
        def ice_staticId():
            return '::SmartHouse::TeaMachine'

        def makeTea(self, teaType, current=None):
            raise NotImplementedError("servant method 'makeTea' not implemented")

        def getAvailableTeaTypes(self, current=None):
            raise NotImplementedError("servant method 'getAvailableTeaTypes' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_SmartHouse._t_TeaMachineDisp)

        __repr__ = __str__

    _M_SmartHouse._t_TeaMachineDisp = IcePy.defineClass('::SmartHouse::TeaMachine', TeaMachine, (), None, (_M_SmartHouse._t_IDrinkMachineDisp,))
    TeaMachine._ice_type = _M_SmartHouse._t_TeaMachineDisp

    TeaMachine._op_makeTea = IcePy.Operation('makeTea', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_SmartHouse._t_TeaType, False, 0),), (), None, (_M_SmartHouse._t_NoIngredientsError, _M_SmartHouse._t_IsOffError))
    TeaMachine._op_getAvailableTeaTypes = IcePy.Operation('getAvailableTeaTypes', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_SmartHouse._t_AvailableTeaTypes, False, 0), (_M_SmartHouse._t_IsOffError,))

    _M_SmartHouse.TeaMachine = TeaMachine
    del TeaMachine

# End of module SmartHouse
